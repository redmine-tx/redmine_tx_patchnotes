<div class="container">
  <!-- 제외 설정 그룹 -->
  <div class="section">
    <h3 class="title">보고 제외 설정</h3>
    <div class="grid">
      <div class="item">
        <h3>이슈 팁 제외 설정</h3>
        <div class="checkbox-wrapper">
          <%= check_box_tag 'settings[no_tip_for_bugs]', '1', Setting[:plugin_redmine_tx_patchnotes][:no_tip_for_bugs] == '1' %>
          <span>QA 일감은 팁을 표시하지 않음</span>
        </div>
      </div>

      

      <div class="item">
        <h3>패치노트 작성이 필요한 일감 유형</h3>
        <div class="select-wrapper">
          <%= select_tag('settings_redmine_tx_patchnotes_trackers_on',
              options_for_select(Tracker.all.order(:name).map { |t| [ t.name, t.id ] },
                selected: Setting[:plugin_redmine_tx_patchnotes][:e_tracker_on].to_s.tr('[]" ','').split(',').map {|i| i.to_i}),
              name: 'settings[e_tracker_on][]',
              multiple: true,
              id: 'required-trackers-select') %>
        </div>
      </div>

      <div class="item">
        <h3>패치노트 작성에서 제외할 일감 유형 (하위 일감들도 제외됨)</h3>
        <div class="select-wrapper">
          <%= select_tag('settings_redmine_tx_patchnotes_trackers_off',
              options_for_select(Tracker.all.order(:name).map { |t| [ t.name, t.id ] },
                selected: Setting[:plugin_redmine_tx_patchnotes][:e_tracker_off].to_s.tr('[]" ','').split(',').map {|i| i.to_i}),
              name: 'settings[e_tracker_off][]',
              multiple: true) %>
        </div>
      </div>

      <div class="item">
        <h3>패치노트가 작성 완료된 일감의 상태</h3>
        <div class="select-wrapper">
          <%= select_tag('settings_redmine_tx_patchnotes_complete',
              options_for_select(IssueStatus.all.map { |s| [s.name, s.id] },
                selected: Setting[:plugin_redmine_tx_patchnotes][:complete].to_s.tr('[]" ','').split(',').map {|i| i.to_i}),
              name: 'settings[complete][]',
              multiple: true) %>
        </div>
      </div>

      <div class="item">
        <h3>패치노트 헤더 <span style="color: #999; font-size: 0.8em;">(레거시 - 마이그레이션용)</span></h3>
        <div class="input-wrapper">
          <%= text_field_tag 'settings[patch_note_header]',
              Setting[:plugin_redmine_tx_patchnotes][:patch_note_header],
              class: 'full-width', disabled: true %>
          <p style="color: #999; font-size: 0.85em; margin-top: 4px;">DB 전환 후 텍스트 마이그레이션에만 사용됩니다.</p>
        </div>
      </div>

      <div class="item">
        <h3>패치노트 스킵 헤더 <span style="color: #999; font-size: 0.8em;">(레거시 - 마이그레이션용)</span></h3>
        <div class="input-wrapper">
          <%= text_field_tag 'settings[patch_skip_header]',
              Setting[:plugin_redmine_tx_patchnotes][:patch_skip_header],
              class: 'full-width', disabled: true %>
          <p style="color: #999; font-size: 0.85em; margin-top: 4px;">DB 전환 후 텍스트 마이그레이션에만 사용됩니다.</p>
        </div>
      </div>

      <div class="item">
        <h3>패치노트 업어도 되는 태그</h3>
        <div class="input-wrapper">
          <%= text_field_tag 'settings[patch_skip_tag]',
              Setting[:plugin_redmine_tx_patchnotes][:patch_skip_tag],
              class: 'full-width' %>
        </div>
      </div>

      <div class="item">
        <h3>패치노트 미공개용 커스텀 필드 <span style="color: #999; font-size: 0.8em;">(레거시 - 마이그레이션용)</span></h3>
        <div class="select-wrapper">
          <%
            # Boolean 타입의 커스텀 필드만 선택
            boolean_custom_fields = IssueCustomField.where(field_format: 'bool').order(:name)
            selected_field = Setting[:plugin_redmine_tx_patchnotes][:internal_note_custom_field].to_s
          %>
          <%= select_tag('settings[internal_note_custom_field]',
              options_for_select(
                [['(선택 안 함)', '']] + boolean_custom_fields.map { |cf| [cf.name, cf.id.to_s] },
                selected: selected_field
              ),
              class: 'full-width', disabled: true) %>
          <p style="color: #999; font-size: 0.85em; margin-top: 5px;">
            DB 전환 후 내부용 여부는 패치노트 작성 시 직접 체크합니다. 마이그레이션에만 사용됩니다.
          </p>
        </div>
      </div>

      <div class="item">
        <h3>패치노트 유형 순서</h3>
        <div class="tracker-order-wrapper">
          <div class="tracker-order-list" id="tracker-order-list">
            <% 
              required_tracker_ids = Setting[:plugin_redmine_tx_patchnotes][:e_tracker_on].to_s.tr('[]" ','').split(',').map {|i| i.to_i}
              tracker_order = Setting[:plugin_redmine_tx_patchnotes][:tracker_order]
              tracker_order = tracker_order.to_s.tr('[]" ','').split(',').map {|i| i.to_i} if tracker_order.present?
              tracker_order = [] if tracker_order.blank?
              
              # 패치노트 작성이 필요한 일감 유형만 필터링
              required_trackers = Tracker.where(id: required_tracker_ids)
              
              # 순서가 설정된 트래커들을 먼저 표시 (필요한 트래커만)
              ordered_trackers = tracker_order.map { |id| required_trackers.find { |t| t.id == id } }.compact
              remaining_trackers = required_trackers.order(:name) - ordered_trackers
              all_trackers = ordered_trackers + remaining_trackers
            %>
            
            <% all_trackers.each do |tracker| %>
              <div class="tracker-order-item" data-tracker-id="<%= tracker.id %>">
                <div class="drag-handle">⋮⋮</div>
                <span class="tracker-name"><%= tracker.name %></span>
              </div>
            <% end %>
          </div>
          <input type="hidden" id="tracker-order-input" name="settings[tracker_order][]" value="">
        </div>
      </div>
      
    </div>
  </div>
</div>

<style>
.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.section {
  background: #fff;
  padding: 20px;
  margin-bottom: 20px;
}

.title {
  color: #2c3e50;
  margin-bottom: 20px;
  border-bottom: 1px solid #eee;
}

.grid {
  display: grid;
  gap: 20px;
}

.item h3 {
  color: #555;
  margin-bottom: 10px;
}

.select-wrapper {
  width: 100%;
}

.input-wrapper {
  width: 100%;
}

.full-width {
  width: 100%;
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
}

@media (min-width: 768px) {
  .grid {
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
  }
}

.tracker-order-wrapper {
  width: 100%;
}

.tracker-order-list {
  border: 1px solid #ddd;
  border-radius: 4px;
  background: #f9f9f9;
  padding: 10px;
  min-height: 100px;
}

.tracker-order-item {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  margin: 4px 0;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: move;
  transition: background-color 0.2s;
}

.tracker-order-item:hover {
  background: #f5f5f5;
}

.tracker-order-item.dragging {
  opacity: 0.5;
}

.drag-handle {
  margin-right: 10px;
  color: #999;
  cursor: grab;
}

.tracker-name {
  flex-grow: 1;
  font-weight: 500;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const trackerOrderList = document.getElementById('tracker-order-list');
  const trackerOrderInput = document.getElementById('tracker-order-input');
  const requiredTrackersSelect = document.getElementById('required-trackers-select');
  
  // 모든 tracker 정보를 저장 (서버에서 가져옴)
  const allTrackers = {};
  <% Tracker.all.each do |tracker| %>
  allTrackers[<%= tracker.id %>] = '<%= tracker.name %>';
  <% end %>
  
  // 현재 순서를 input에 저장
  function updateTrackerOrder() {
    const items = trackerOrderList.querySelectorAll('.tracker-order-item');
    const order = Array.from(items).map(item => item.dataset.trackerId);
    trackerOrderInput.value = order.join(',');
  }
  
  // 선택된 tracker들로 순서 목록 업데이트
  function updateTrackerOrderList() {
    const selectedValues = Array.from(requiredTrackersSelect.selectedOptions).map(option => option.value);
    const currentOrder = trackerOrderInput.value.split(',').filter(id => id);
    
    // 기존 순서 중 선택된 것들만 유지
    const filteredOrder = currentOrder.filter(id => selectedValues.includes(id));
    
    // 새로 선택된 것들을 뒤에 추가
    const newTrackers = selectedValues.filter(id => !filteredOrder.includes(id));
    const finalOrder = filteredOrder.concat(newTrackers);
    
    // DOM 업데이트
    trackerOrderList.innerHTML = '';
    finalOrder.forEach(trackerId => {
      const trackerItem = document.createElement('div');
      trackerItem.className = 'tracker-order-item';
      trackerItem.setAttribute('data-tracker-id', trackerId);
      trackerItem.setAttribute('draggable', true);
      trackerItem.innerHTML = `
        <div class="drag-handle">⋮⋮</div>
        <span class="tracker-name">${allTrackers[trackerId]}</span>
      `;
      trackerOrderList.appendChild(trackerItem);
    });
    
    updateTrackerOrder();
  }
  
  // 초기 순서 설정
  updateTrackerOrder();
  
  // 필요한 tracker 선택 변경 감지
  requiredTrackersSelect.addEventListener('change', function() {
    updateTrackerOrderList();
  });
  
  // 드래그 앤 드롭 기능
  let draggedItem = null;
  
  trackerOrderList.addEventListener('dragstart', function(e) {
    if (e.target.classList.contains('tracker-order-item')) {
      draggedItem = e.target;
      e.target.classList.add('dragging');
    }
  });
  
  trackerOrderList.addEventListener('dragend', function(e) {
    if (e.target.classList.contains('tracker-order-item')) {
      e.target.classList.remove('dragging');
      draggedItem = null;
    }
  });
  
  trackerOrderList.addEventListener('dragover', function(e) {
    e.preventDefault();
    const afterElement = getDragAfterElement(trackerOrderList, e.clientY);
    if (afterElement == null) {
      trackerOrderList.appendChild(draggedItem);
    } else {
      trackerOrderList.insertBefore(draggedItem, afterElement);
    }
    updateTrackerOrder();
  });
  
  function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.tracker-order-item:not(.dragging)')];
    
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      
      if (offset < 0 && offset > closest.offset) {
        return { offset: offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }
  
  // 모든 tracker-order-item에 draggable 속성 추가
  document.querySelectorAll('.tracker-order-item').forEach(item => {
    item.setAttribute('draggable', true);
  });
});
</script>

